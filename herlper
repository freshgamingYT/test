import RPi.GPIO as GPIO
import time

from logger import setup_logger
from fileHandler import FileHandler

class StetterInit:
    nullPos = 0
    maxPos = 0
    aktuellePos = 0

    # Pin configuration
    STEP = 17
    DIR = 27
    EN = 23
    schalterLinksPin = 16
    schalterRechtsPin = 24

    # Timing and delay
    us_delay = 950
    uS = 0.00001       # 0.00001 normal

    def __init__(self):
        self.logger = setup_logger()
        self.logger.debug("logger initialized")
        self.GPIOConfig()
        self.positionsFileHandler = FileHandler('../json/positions.json')
        self.positions = self.positionsFileHandler.readJson()

    def GPIOConfig(self):
        # GPIO setup
        GPIO.setmode(GPIO.BCM)
        GPIO.setwarnings(False)

        GPIO.setup(self.STEP, GPIO.OUT)
        GPIO.setup(self.DIR, GPIO.OUT)
        GPIO.setup(self.EN, GPIO.OUT)

        GPIO.setup(self.schalterLinksPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        GPIO.setup(self.schalterRechtsPin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        GPIO.output(self.EN, GPIO.LOW)
        
        self.logger.info("Setup GPIO")


    def initMoveMotor(self, direction, stop_condition): # stop_condition is reference to getSchalterStatus
        """Move the motor in the specified direction until the stop condition is met."""
        self.logger.debug("In initMoveMotor")

        GPIO.output(self.DIR, direction)
        while not stop_condition():
            GPIO.output(self.STEP, GPIO.HIGH)
            time.sleep(self.uS * self.us_delay)
            GPIO.output(self.STEP, GPIO.LOW)
            time.sleep(self.uS * self.us_delay)

            self.logger.info("moved Motor 1 Step")
            
            if direction == GPIO.HIGH:
                self.aktuellePos += 1
                self.logger.info(f"new aktuellePos is {self.aktuellePos}")
        
    def getSchalterRechtsStatus(self) -> bool:
        """Check the status of the right limit switch."""
        self.logger.info(f"status of right button {GPIO.input(self.schalterRechtsPin)}")
        return GPIO.input(self.schalterRechtsPin) == 1

    def getSchalterLinksStatus(self) -> bool:
        """Check the status of the left limit switch."""
        self.logger.info(f"status of right button {GPIO.input(self.schalterLinksPin)}")
        return GPIO.input(self.schalterLinksPin) == 1

    def init(self):
        """Execute the exact sequence: left ? right ? left."""
        self.logger.info("Step 1: Moving left...")
        self.initMoveMotor(GPIO.LOW, self.getSchalterLinksStatus)  # Move left until left button is pressed
        self.nullPos = 0
        self.logger.info(f"Left limit switch reached!, nullPos: {self.nullPos} ")
        time.sleep(1)

        self.logger.info("Step 2: Moving right...")
        self.initMoveMotor(GPIO.HIGH, self.getSchalterRechtsStatus)  # Move right until right button is pressed
        self.maxPos = self.aktuellePos
        self.logger.info(f"Right limit switch reached!, maxPos: {self.maxPos}, aktuellePos: {self.aktuellePos}")
        time.sleep(1)

        self.logger.info("Step 3: Moving left again...")
        self.initMoveMotor(GPIO.LOW, self.getSchalterLinksStatus)  # Move left until left button is pressed
        self.aktuellePos = 0
        self.logger.info(f"Left limit switch reached again!, aktuellePos: {self.aktuellePos}")
        time.sleep(1)

        self.moveToDefPos()
        # self.logger.debug("Sequence complete. Stopping motor.")
    
    # return the console input
    def setNewRelPos(self) -> int:
        self.consoleInput = int(input("Gebe Anzahl an Steps fÃ¼r den Motor nach folgendem Schema an: Richtung: +/-, AnzSteps als int: "))
        self.logger.info(f"console input is: {self.consoleInput}")
        return self.consoleInput

    # checks if newPos is lower than aktpos 
    #   -> GPIO.LOW(nach links) and moves servo to the left 
    # or higher than aktPos 
    #   -> GPIO.HIGH(nach rechts) and moves servo to the right 
    # or if entry was 0

    def moveRelPos(self, newRelPos, aktuellePos):
        self.logger.debug("entering moveRelPos")

        if newRelPos == 0:
            print("Die Eingabe is 0, es wird nichts passieren")
            self.logger.info("Die Eingabe is 0, es wird nichts passieren")
        if newRelPos < 0:
            self.logger.info("newRelPos is positive")
            GPIO.output(self.DIR, GPIO.LOW)
            self.aktPos = aktuellePos
            while self.aktPos > newRelPos or self.aktPos == self.nullPos:
                GPIO.output(self.STEP, GPIO.HIGH)
                time.sleep(self.uS * self.us_delay)
                GPIO.output(self.STEP, GPIO.LOW)
                time.sleep(self.uS * self.us_delay)
                self.aktPos -= 1
                
                print(f"moved to position: {newRelPos}")
                self.logger.info(f"moved to position: {newRelPos}")


        elif newRelPos > 0:
            self.logger.info("newRelPos is negative")
            GPIO.output(self.DIR, GPIO.HIGH)
            self.aktPos = 0
            while self.aktPos < newRelPos or newRelPos + self.aktPos == self.maxPos:
                GPIO.output(self.STEP, GPIO.HIGH)
                time.sleep(self.uS * self.us_delay)
                GPIO.output(self.STEP, GPIO.LOW)
                time.sleep(self.uS * self.us_delay)
                self.aktPos += 1
                
                print(f"moved to position: {newRelPos}")
                self.logger.info(f"moved to position: {newRelPos}")

    def moveToDefPos(self):
        print("Available Positions:")
        for position_name, steps in self.positions.items():
            print(f"- {position_name}: {steps} steps")

        while 1:
            try:
                user_input = input("Enter position name or 'q' to quit: ")
                if user_input.lower() == 'q':
                    break

                if user_input in self.positions:
                    target_steps = self.positions[user_input]
                    self.move_to_position(target_steps)
                else:
                    print(f"Invalid position: {user_input}")

            except KeyboardInterrupt:
                print("Exiting program...")
                break

            if self.getSchalterLinksStatus() or self.getSchalterRechtsStatus():
                print("Limit switch triggered! Stopping motor.")
                break

    def move_to_position(self, target_steps):
        """Moves the motor to the specified position."""
        relative_steps = target_steps - self.aktuellePos
        self.move_rel_pos(relative_steps)
        self.aktuellePos = target_steps

if __name__ == "__main__":
    try:
        stepper = StetterInit()
        stepper.init()
        
    except KeyboardInterrupt:
        print("Exiting program...")
    finally:
        GPIO.cleanup()  # Cleanup GPIO settings on exit
